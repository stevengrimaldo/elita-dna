@mixin font($font-weight: $base-font-weight, $font-family: $primary-font-family) {
  font-family: $font-family;
  font-weight: $font-weight;
}
@mixin letter-spacing($ps-value, $font-size) {
  letter-spacing: (($ps-value * $font-size) / 1000) + px;
}
@mixin clearfix {
  &::before,
  &::after {
    content: '';
    display: table;
  }
  &::after {
    clear: both;
  }
}
// =============================================================================
// REM Unit Converter
// =============================================================================
@mixin rem($property, $values) {
  // Create a couple of empty lists as output buffers.
  $font-size: $base-font-size;
  $px-values: ();
  $rem-values: ();

  // Loop through the $values list
  @each $value in $values {
    // For each property value, if it's in rem or px, derive both rem and
    // px values for it and add those to the end of the appropriate buffer.
    // Ensure all pixel values are rounded to the nearest pixel.
    @if $value == 0 or $value == 0px {
      // 0 -- use it without a unit
      $px-values: join($px-values, 0);
      $rem-values: join($rem-values, 0);
    } @else if type-of($value) == number and not unitless($value) and unit($value) == px {
      // px value given - calculate rem value from font-size
      $new-rem-value: $value / $font-size;
      $px-values: join($px-values, round($value));
      $rem-values: join($rem-values, #{$new-rem-value}rem);
    } @else if type-of($value) == number and not unitless($value) and unit($value) == '%' {
      // % value given - don't add px or rem
      $px-values: join($px-values, #{$value});
      $rem-values: join($rem-values, #{$value});
    } @else if $value == auto {
      // auto - don't add px or rem
      $px-values: join($px-values, auto);
      $rem-values: join($rem-values, auto);
    } @else {
      // unitless value - use those directly as rem and calculate the px-fallback
      $px-values: join($px-values, round($value * $font-size));
      $rem-values: join($rem-values, #{$value}rem);
    }
  }

  // output the converted rules
  #{$property}: $px-values;
  #{$property}: $rem-values;
}
// =============================================================================
// Responsive Width
// =============================================================================
@mixin rspw($max-width, $context, $padding: 0, $margin: 0) {
  @if ($context) {
    @if ($max-width) {
      $newcontext: ($context - $padding - $margin);
      max-width: $max-width;
      width: pc($max-width, $newcontext);
    }
  }
}
// =============================================================================
// Aspect Ratio
// =============================================================================
@mixin aspect-ratio($width, $height) {
  position: relative;
  &::before {
    display: block;
    content: ' ';
    width: 100%;
    padding-top: ($height / $width) * 100%;
  }
  > * {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
}
// =============================================================================
// Media Query
// =============================================================================
// Supports
// @include mq($max, breakpoint) {}
// @include mq('', min-breakpoint, max-breakpoint) {}
// @include mq($min, breakpoint) {}
@mixin mq($constraint, $viewport1, $viewport2: null) {
  $vp1: $viewport1 / 16;
  @if $constraint == $min {
    @media screen and ($min: #{$vp1}em) {
      @content;
    }
  } @else if $constraint == $max {
    @media screen and ($max: #{$vp1}em) {
      @content;
    }
  } @else {
    $vp2: $viewport2 / 16;
    @media screen and ($min: #{$vp1}em) and ($max: #{$vp2}em) {
      @content;
    }
  }
}
// =============================================================================
// Font Face
// =============================================================================
@mixin font-face($name, $path, $weight: null, $style: null, $exts: eot woff2 woff ttf svg) {
  $src: null;

  $extmods: (
    eot: '?',
    svg: '#' + str-replace($name, ' ', '_')
  );

  $formats: (
    otf: 'opentype',
    ttf: 'truetype'
  );

  @each $ext in $exts {
    $extmod: if(map-has-key($extmods, $ext), $ext + map-get($extmods, $ext), $ext);
    $format: if(map-has-key($formats, $ext), map-get($formats, $ext), $ext);
    $src: append($src, url(quote($path + '.' + $extmod)) format(quote($format)), comma);
  }

  @font-face {
    font-family: quote($name);
    font-style: $style;
    font-weight: $weight;
    src: $src;
  }
}
// =============================================================================
// Angle
// =============================================================================
@mixin angle($pseudo, $flip: false, $angle: 3deg, $background: inherit) {
  // Possible values for $pseudo are: before, after, both
  @if $pseudo == 'before' or $pseudo == 'after' or $pseudo == 'both' {
    position: relative;
    z-index: 1;
    $selector: if($pseudo == 'both', '&:before, &:after', '&:#{$pseudo}');

    #{$selector} {
      background: $background;
      content: '';
      display: block;
      height: 50%;
      left: 0;
      position: absolute;
      right: 0;
      z-index: -1;
      -webkit-backface-visibility: hidden; // for Chrome Windows
    }

    @if $pseudo == 'before' {
      #{$selector} {
        top: 0;

        @if $flip {
          transform: skewY($angle * -1);
          transform-origin: 0 0;
        } @else {
          transform: skewY($angle);
          transform-origin: 100% 0;
        }
      }
    }

    @if $pseudo == 'after' {
      #{$selector} {
        bottom: 0;

        @if $flip {
          transform: skewY($angle);
          transform-origin: 0 100%;
        } @else {
          transform: skewY($angle * -1);
          transform-origin: 100%;
        }
      }
    }

    @if $pseudo == 'both' {
      &:before {
        top: 0;

        @if $flip {
          transform: skewY($angle * -1);
          transform-origin: 0 0;
        } @else {
          transform: skewY($angle);
          transform-origin: 100% 0;
        }
      }

      &:after {
        bottom: 0;

        @if $flip {
          transform: skewY($angle);
          transform-origin: 0 0;
        } @else {
          transform: skewY($angle * -1);
          transform-origin: 100%;
        }
      }
    }
  }
}
